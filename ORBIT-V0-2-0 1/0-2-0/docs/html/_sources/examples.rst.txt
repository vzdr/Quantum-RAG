Examples and Tutorials
======================

This section provides practical examples and tutorials for using the ORBIT simulator effectively.

Quick Start Examples
--------------------

Simple Ising Problem
~~~~~~~~~~~~~~~~~~~~~

A complete example showing how to set up and run a basic Ising optimization problem:

.. code-block:: python

   import numpy as np
   import orbit.simulator as sim

   # Create a simple 2-node Max-Cut problem
   coupling_matrix = np.array([[0, 1], [1, 0]], dtype=np.float64)
   external_field = np.array([0.1, -0.1], dtype=np.float64)

   # Create configuration using the helper function
   config = sim.create_ising_simulation(
       coupling_matrix=coupling_matrix,
       external_field=external_field,
       n_replicas=3,
       max_full_sweeps=100,
       beta_initial=1.5,  # Temperature parameter
       random_seed=42
   )

   # Run simulation
   controller = sim.Controller(config)
   results = controller.run()

   # Analyze results
   print(f"Execution time: {results.execution_time:.3f}s")
   combined_samples = results.get_combined_samples()
   final_state = combined_samples[-1]

   # Calculate energy of final state
   energy = -0.5 * final_state.T @ coupling_matrix @ final_state - external_field.T @ final_state
   print(f"Final energy: {energy}")

Configuration Management
~~~~~~~~~~~~~~~~~~~~~~~~

Working with Pydantic-based configurations:

.. code-block:: python

   import orbit.simulator as sim
   from pathlib import Path

   # Create configuration programmatically
   config = sim.create_ising_simulation(
       coupling_matrix=np.eye(3),
       external_field=np.array([0.5, 0, -0.5]),
       n_replicas=5,
       max_full_sweeps=200
   )

   # Save configuration to JSON
   sim.save_config_to_json(config, "my_config.json")

   # Load configuration from JSON
   loaded_config = sim.load_config_from_json("my_config.json")

   # Validate configuration dictionary
   config_dict = {...}  # Your config data
   is_valid, errors = sim.validate_config(config_dict)
   if not is_valid:
       print("Validation errors:", errors)

Comprehensive Examples
----------------------

The ``examples/`` directory contains detailed, working examples:

Simulator Examples (``examples/simulator_example.py``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This comprehensive example demonstrates:

* **Simple Ising Problems** - Basic 4-node Max-Cut optimization
* **Complex Optimization** - Problems with external fields and temperature sweeps
* **Convergence Analysis** - Statistical analysis of simulation behavior
* **Parameter Optimization** - Systematic testing of β and replica parameters
* **Large-Scale Performance** - Testing on 20-node problems

Run the full example:

.. code-block:: bash

   uv run python examples/simulator_example.py

Configuration Examples (``examples/pydantic_configuration.py``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Focused examples for the Pydantic configuration system:

* Creating configurations programmatically
* Loading/saving configurations to JSON
* Configuration validation with error handling
* Integration with simulation workflows

Run configuration examples:

.. code-block:: bash

   uv run python examples/pydantic_configuration.py

Logging Examples (``examples/logging_example.py``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Comprehensive examples for the logging system:

* Global logging configuration and log levels
* File logging with automatic timestamping
* Performance optimization with silent operation
* Multi-controller logging behavior

Key features demonstrated:

* **Log Levels**: INFO (progress), WARNING (minimal), ERROR (silent)
* **File Logging**: Automatic timestamp and directory creation
* **Performance**: Zero overhead when logging is disabled
* **Global Configuration**: Set once, use everywhere

Run logging examples:

.. code-block:: bash

   uv run python examples/logging_example.py

Advanced Usage Patterns
-----------------------

Logging and Output Control
~~~~~~~~~~~~~~~~~~~~~~~~~~

Control simulation output with the professional logging system:

.. code-block:: python

   from orbit.utils.logging import LogLevel

   # Detailed progress logging (default)
   config = sim.create_ising_simulation(
       coupling_matrix=coupling_matrix,
       external_field=external_field,
       n_replicas=5,
       log_level=LogLevel.INFO
   )

   # Silent operation for performance
   config_silent = sim.create_ising_simulation(
       coupling_matrix=coupling_matrix,
       external_field=external_field,
       n_replicas=5,
       log_level=LogLevel.ERROR  # No progress output
   )

   # File logging with timestamps
   config_file = sim.create_ising_simulation(
       coupling_matrix=coupling_matrix,
       external_field=external_field,
       n_replicas=5,
       log_level=LogLevel.INFO,
       log_file="experiment"  # Creates logs/experiment_TIMESTAMP.log
   )

Performance benefits of proper log levels:

* **INFO level**: Shows progress, good for debugging
* **ERROR level**: ~8x faster execution, ideal for parameter sweeps
* **File logging**: Persistent logs with automatic timestamping

Temperature Sweeps
~~~~~~~~~~~~~~~~~~

Explore how temperature affects optimization:

.. code-block:: python

   # Test different temperatures
   temperatures = [0.5, 1.0, 2.0]
   results_by_temp = {}

   for temp in temperatures:
       config = sim.create_ising_simulation(
           coupling_matrix=coupling_matrix,
           external_field=external_field,
           n_replicas=3,
           max_full_sweeps=200,
           beta_initial=1.0/temp,  # β = 1/T
           random_seed=42
       )

       controller = sim.Controller(config)
       results = controller.run()
       results_by_temp[temp] = results

Multi-Problem Analysis
~~~~~~~~~~~~~~~~~~~~~~

Analyze convergence across different problem instances:

.. code-block:: python

   convergence_times = []
   final_energies = []

   for run in range(10):
       config = sim.create_ising_simulation(
           coupling_matrix=coupling_matrix,
           external_field=external_field,
           n_replicas=4,
           max_full_sweeps=500,
           beta_initial=1.0,
           random_seed=run * 100  # Different seed each run
       )

       controller = sim.Controller(config)
       results = controller.run()

       convergence_times.append(results.convergence_data['mean_iterations'])
       # Calculate final energy and store...

Results Analysis
----------------

Working with Simulation Results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The simulator returns rich ``SimulationResult`` objects with analysis capabilities:

.. code-block:: python

   # Run simulation
   results = controller.run()

   # Basic information
   print(f"Execution time: {results.execution_time:.3f}s")
   print(f"Number of replicas: {len(results.samples)}")
   print(f"Convergence iterations: {results.convergence_data['mean_iterations']}")

   # Access sample data
   combined_samples = results.get_combined_samples()
   print(f"Combined samples shape: {combined_samples.shape}")

   # Statistical analysis
   stats = results.get_sample_statistics()
   print(f"Sample mean: {stats['mean']}")
   print(f"Sample std: {stats['std']}")

Visualization and Analysis
~~~~~~~~~~~~~~~~~~~~~~~~~~

Analyze and visualize simulation behavior:

.. code-block:: python

   import matplotlib.pyplot as plt

   # Plot convergence over time
   final_samples = results.get_combined_samples()[-50:]  # Last 50 samples
   energies = []
   for sample in final_samples:
       energy = -0.5 * sample.T @ coupling_matrix @ sample
       energies.append(energy)

   plt.plot(energies)
   plt.xlabel('Sample')
   plt.ylabel('Energy')
   plt.title('Energy Convergence')
   plt.show()

Performance Considerations
--------------------------

Tips for optimal simulation performance:

* **Problem Size**: Larger networks require more memory and computation time
* **Replica Count**: More replicas improve sampling but increase execution time
* **Iterations**: Balance convergence quality vs. execution time
* **Temperature (β)**: Higher β (lower temperature) requires more iterations to converge

Typical performance characteristics:

* **Small problems** (2-4 nodes): < 0.1s execution time
* **Medium problems** (8-10 nodes): 0.1-1s execution time
* **Large problems** (20+ nodes): 1-10s execution time

.. note::

   More examples and tutorials will be added as the platform develops.
   Check the project repository for the latest examples and use cases.

Testing and Validation
----------------------

The project includes comprehensive tests for the simulator:

.. code-block:: bash

   # Run all tests
   uv run pytest tests/ -v

   # Run specific test categories
   uv run pytest tests/test_simulator_functionality.py -v
   uv run pytest tests/test_simulator_example.py -v

   # Run with coverage
   uv run pytest --cov=src --cov-report=html

Current test coverage includes:

* **Core simulator functionality** (12 tests) - Basic operations and energy calculations
* **Example structure validation** (7 tests) - File structure and documentation
* **Pydantic integration** (11 tests) - Configuration validation and serialization

Known Issues
------------

**IsingCalculator State Persistence**: The current implementation uses class-level attributes
that persist between instances. When running problems of different sizes sequentially, this
can cause index out-of-bounds errors. The test suite includes workarounds for this issue.

Next Steps
----------

After working through these examples:

1. Explore the full :doc:`api/orbit` for advanced features
2. Review the :doc:`simulator` guide for detailed component usage
3. Run the comprehensive examples in the ``examples/`` directory
4. Check the test suite for additional usage patterns

For project setup and installation, refer to the README in the repository.
