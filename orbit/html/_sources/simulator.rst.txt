Using the Simulator
===================

The ORBIT simulator provides a comprehensive environment for modeling probabilistic computing systems with a modern Pydantic-based configuration system. This guide covers the core concepts, components, and usage patterns.

Quick Start
-----------

The simplest way to get started is using the helper functions:

.. code-block:: python

   import numpy as np
   import orbit.simulator as sim

   # Create a 2-node Ising problem
   coupling_matrix = np.array([[0, 1], [1, 0]], dtype=np.float64)
   external_field = np.array([0.1, -0.1], dtype=np.float64)

   # Create model and configuration
   sim_model, config = sim.create_ising_simulation(
       coupling_matrix=coupling_matrix,
       external_field=external_field,
       n_replicas=3,
       max_full_sweeps=100,
       beta_initial=1.5,
       random_seed=42
   )

   # Create simulator and run
   simulator = sim.Simulator(sim_model, config)
   results = simulator.run()

Core Components
---------------

The simulator is built around several key components that work together to model probabilistic computing behavior:

Configuration System
~~~~~~~~~~~~~~~~~~~~

The simulator uses Pydantic models for type-safe, validated configuration:

.. code-block:: python

   from orbit.simulator import SimulationConfig, ControllerConfig, ReplicaConfig

   # Configurations are automatically validated
   sim_model, config = sim.create_ising_simulation(
       coupling_matrix=coupling_matrix,
       external_field=external_field,
       n_replicas=5,
       max_full_sweeps=200
   )

   # Access configuration components
   print(f"Replicas: {config.controller_config.n_replicas}")
   print(f"Max processes: {config.controller_config.max_processes}")

   # Save/load configurations
   sim.save_config_to_json(config, "config.json")
   loaded_config = sim.load_config_from_json("config.json")

Simulator and Controller System
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :class:`~orbit.simulator.components.simulator.Simulator` orchestrates the entire simulation workflow, while the :class:`~orbit.simulator.components.controller.Controller` manages execution across replicas:

.. code-block:: python

   from orbit.simulator import Simulator, Controller

   # Create model and configuration
   sim_model, config = sim.create_ising_simulation(...)

   # Initialize simulator (handles setup and logging)
   simulator = Simulator(sim_model, config)
   results = simulator.run()

   # Access results
   print(f"Execution time: {results.execution_time:.3f}s")
   print(f"Iterations per replica: {results.total_iterations}")
   combined_samples = results.get_combined_samples()

   # The Simulator internally uses Controller to manage replica execution
   # Controller parameters are configured through ControllerConfig

Network Architecture
~~~~~~~~~~~~~~~~~~~~

The :class:`~orbit.simulator.components.network.Network` class represents topology and connections:

.. code-block:: python

   # Networks are automatically created from coupling matrices
   # For custom topologies:
   adjacency = {0: {1, 2}, 1: {0, 2}, 2: {0, 1}}  # Fully connected 3-node
   update_groups = [0, 0, 0]  # Single update group

   config = sim.create_ising_simulation(
       coupling_matrix=coupling_matrix,
       external_field=external_field,
       adjacency=adjacency,
       update_groups=update_groups
   )

Bias Calculation
~~~~~~~~~~~~~~~~

The :class:`~orbit.simulator.components.bias_calculators.ising_calculator.IsingCalculator` handles Ising model calculations:

.. code-block:: python

   # Bias calculation is automatic with Ising configurations
   # Energy: E = -0.5 * s^T * J * s - h^T * s
   # where J is coupling matrix, h is external field, s is state

Simulation Workflow
-------------------

A typical simulation workflow involves:

1. **Problem Definition** - Define coupling matrix and external fields
2. **Factory Creation** - Use ``create_ising_simulation()`` helper to get model and config
3. **Simulator Setup** - Initialize ``Simulator`` with model and config
4. **Execution** - Run simulation with ``simulator.run()``
5. **Analysis** - Extract and analyze results

.. code-block:: python

   # 1. Define problem
   coupling_matrix = np.array([[0, 1, -1], [1, 0, 1], [-1, 1, 0]])
   external_field = np.array([0.5, 0, -0.5])

   # 2. Create model and configuration
   sim_model, config = sim.create_ising_simulation(
       coupling_matrix=coupling_matrix,
       external_field=external_field,
       n_replicas=5,
       max_full_sweeps=200,
       beta_initial=1.5,
       random_seed=42
   )

   # 3. Create simulator
   simulator = sim.Simulator(sim_model, config)

   # 4. Execute simulation
   results = simulator.run()

   # 5. Analyze results
   combined_samples = results.get_combined_samples()
   stats = results.get_sample_statistics()
   print(f"Completed in {results.execution_time:.2f}s")

Advanced Features
-----------------

Logging and Output Control
~~~~~~~~~~~~~~~~~~~~~~~~~~

The simulator uses a professional logging system with configurable levels. Logging is configured through ``SimulationConfig``:

.. code-block:: python

   from orbit.utils.logging import LogLevel

   # Create configurations with different log levels
   sim_model_info, config_info = sim.create_ising_simulation(
       coupling_matrix=coupling_matrix,
       external_field=external_field,
       n_replicas=3,
       log_level=LogLevel.INFO  # Shows progress updates
   )

   sim_model_silent, config_silent = sim.create_ising_simulation(
       coupling_matrix=coupling_matrix,
       external_field=external_field,
       n_replicas=3,
       log_level=LogLevel.ERROR  # Silent operation
   )

   # File logging with automatic timestamping
   sim_model_file, config_file = sim.create_ising_simulation(
       coupling_matrix=coupling_matrix,
       external_field=external_field,
       n_replicas=3,
       log_level=LogLevel.INFO,
       log_file="simulation"  # Creates logs/simulation_TIMESTAMP.log
   )

   # Run simulators with different configurations
   simulator = sim.Simulator(sim_model_info, config_info)
   results = simulator.run()

Available log levels:

* ``LogLevel.DEBUG`` - Detailed debugging information
* ``LogLevel.INFO`` - Progress updates and completion messages (default)
* ``LogLevel.WARNING`` - Only warnings and errors
* ``LogLevel.ERROR`` - Only errors (silent operation)
* ``LogLevel.CRITICAL`` - Only critical errors

Multi-Replica Execution
~~~~~~~~~~~~~~~~~~~~~~~

The simulator automatically manages parallel replicas for improved sampling:

.. code-block:: python

   # Configure multiple replicas
   sim_model, config = sim.create_ising_simulation(
       coupling_matrix=coupling_matrix,
       external_field=external_field,
       n_replicas=10,  # Run 10 parallel replicas
       max_processes=4,  # Use up to 4 processes
       max_full_sweeps=500
   )

   simulator = sim.Simulator(sim_model, config)
   results = simulator.run()
   print(f"Samples from {len(results.samples)} replicas")
   print(f"Used {results.metadata['n_processes_used']} processes")

Temperature Control
~~~~~~~~~~~~~~~~~~~

Control exploration vs exploitation with the temperature parameter:

.. code-block:: python

   # High temperature (low β) - more exploration
   config_hot = sim.create_ising_simulation(..., beta_initial=0.5)

   # Low temperature (high β) - more exploitation
   config_cold = sim.create_ising_simulation(..., beta_initial=3.0)

Configuration Validation
~~~~~~~~~~~~~~~~~~~~~~~~

Built-in validation ensures configuration correctness:

.. code-block:: python

   # Validate configuration dictionaries before creating models
   config_dict = {
       "controller_config": {
           "n_replicas": 5,
           "max_processes": 2,
           "replica_config": {
               "max_full_sweeps": 1000,
               "beta_initial": 1.0,
               "beta_step_size": 0.003,
               "beta_step_interval": 1
           }
       }
   }

   is_valid, errors = sim.validate_config(config_dict)
   if not is_valid:
       print("Validation errors:", errors)
   else:
       print("Configuration is valid")

Performance Considerations
--------------------------

Tips for optimizing simulation performance:

**Problem Size Scaling**

* **Small problems** (2-4 nodes): < 0.1s execution time
* **Medium problems** (8-10 nodes): 0.1-1s execution time
* **Large problems** (20+ nodes): 1-10s execution time

**Parameter Tuning**

* **Replica Count**: More replicas improve sampling but increase execution time
* **Iterations**: Balance convergence quality vs. execution time
* **Temperature (β)**: Higher β requires more iterations but finds better solutions

**Memory Optimization**

* Large coupling matrices consume significant memory
* Consider sparse representations for large, sparse problems
* Monitor memory usage with many replicas

**Parallel Execution**

The simulator automatically uses multiprocessing for replica execution:

.. code-block:: python

   # Replicas run in parallel automatically
   config = sim.create_ising_simulation(
       coupling_matrix=large_matrix,
       external_field=large_field,
       n_replicas=8  # Will use multiple CPU cores
   )

Component Architecture
----------------------

The simulator is composed of several key components that work together:

**Simulator**
   Orchestrates the entire simulation workflow, handles logging configuration and manages the simulation lifecycle.

**Controller**
   Manages replica execution and coordinates between replicas and the network components.

**Replica**
   Represents a single parallel instance of the simulation, managing p-bits, bias calculations, and state sampling.

**Network**
   Manages the topology of p-bits and update groups for efficient computation.

**Bias Calculators**
   Abstract interface for calculating p-bit biases. Currently implements ``IsingCalculator`` for Ising model problems.

Known Issues
------------

**IsingCalculator State Persistence**: The current implementation uses class-level attributes
that can cause cross-contamination between different problem sizes. This is a known issue
being addressed in future versions.

Examples and Testing
--------------------

For comprehensive examples, see:

* ``examples/simulator_example.py`` - Full simulator usage examples
* ``examples/pydantic_configuration.py`` - Configuration system examples
* ``tests/test_simulator_functionality.py`` - Test suite with usage patterns

Run examples:

.. code-block:: bash

   # Comprehensive simulator examples
   uv run python examples/simulator_example.py

   # Configuration examples
   uv run python examples/pydantic_configuration.py

   # Run test suite
   uv run pytest tests/ -v

For installation and basic setup, see the project README.
